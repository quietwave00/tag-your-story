# #TagYourStory
`Spring Boot` `Spring Data JPA` `Spring Security` `Spring Batch` `MySQL` `Redis` `Java 17` `JavaScript`

**#TagYourStory**는 음악을 검색하여 개인 이야기를 기록할 수 있는 서비스입니다.

## 소개
* 프론트(Vanilla JS)과 3개의 스프링 모듈(api/core/batch)로 구성된 프로젝트입니다.
* 서비스의 처음부터 끝을 경험해 보고자 프론트, 백, 인프라를 구축했습니다.
* 깃 브랜치 전략을 통해 버전업을 기획하고 지속적인 업데이트 중입니다.

## 아키텍처
<img width="1234" alt="image" src="https://github.com/quietwave00/tag-your-story/assets/51073778/bbadefd3-70b8-43b3-92f1-c025501e7496">


## 프로젝트 내용
### 1. Spring Security와 JWT
* JWT를 이용하여 액세스 토큰과 리프레시 토큰으로 구성된 **토큰 기반의 인증 시스템**을 구현하였습니다.
* 사용자가 반복적인 인증 프로세스를 거치지 않도록 하기 위하여 액세스 토큰 만료 시,
    레디스에 저장되는 **리프레시 토큰을 이용하여 콜백 함수로 액세스 토큰을 재발급**받을 수 있도록 설계하였습니다.

### 2. Redis
본 프로젝트에서 레디스는 다음과 같은 목적으로 사용되었습니다.
* **데이터의 조회 목적**
    TTL(Time To Live)이 존재하는 리프레시 토큰, 라이브러리의 인증 토큰과 같이 수정이 빈번하게 일어날 수 있는 데이터의 조회 목적을 위하여 사용하였습니다.
* **캐싱 목적**
    조회가 자주 일어나는 사용자, 파일 데이터를 캐싱하여 더 빠른 정보를 제공하기 위해 사용하였습니다.
* **자료구조 이용**
    Redis의 zset 자료구조를 이용하여 인기 검색어를 구현하였습니다.

저장 대상의 스펙을 **Enum**을 활용하여 관리하고 이를 조회・저장・삭제할 수 있는 **범용적인 RedisTemplate을 커스텀하여 구현**했습니다.
그 결과, 재사용성이 증가하였고 캐싱 대상에 대한 일관된 컨벤션을 수립할 수 있었습니다.
<br>

### 3. Spring Batch와 젠킨스
<img width="1338" alt="image-1" src="https://github.com/quietwave00/tag-your-story/assets/51073778/30bb9fe1-7551-4449-b3ea-f29b65b4cc91">

* 도입 배경
    * 사용자가 업로드한 파일은 서버를 통해 AWS S3 버킷에 저장되게 됩니다.
        클라이언트에서 삭제 요청 시, 매번 S3에 삭제 요청을 하는 것은 리소스가 크다고 판단하여 배치 작업을 도입하게 되었습니다.
    * batch 모듈을 api 모듈과 분리하여 관리하고자 **스케쥴링 모니터링이 가능한 젠킨스를 도입**하였고,
        **배포 프로세스는 깃허브 액션을 통해 이루어지는 점을 고려**하여 **웹훅을 구성**하였습니다.

* 구현
    * 처리해야 하는 파일의 수가 많아지는 경우를 고려하여 chunkSize를 두고, ItemReader(Soft Delete된 파일 데이터 읽기), ItemProcessor(S3 삭제 요청)의 작업을 구현하였습니다.

### 4. Spring Event와 SSE(Sever-Sent Events)를 활용한 실시간 알림 기능
<img width="1344" alt="image-2" src="https://github.com/quietwave00/tag-your-story/assets/51073778/cf9c3f65-8037-4347-8996-1b517254674a">

<br>

* 도입 배경
    * 사용자가 실시간으로 게시글에 대한 알림을 받아볼 수 있도록, 클라이언트에서 서버로부터 지속적인 메시지를 받을 수 있는 방법이 필요했습니다.
    * 클라이언트와 서버 간 양방향 통신이 필요 없는 점, 애플리케이션의 크기를 고려하여 **단방향 통신이 가능한 SSE를 선택**하게 되었습니다.
* 구현
    * 게시글을 작성하는 비즈니스 로직에서 알림 이벤트가 발행됩니다. 게시글 도메인과 알림 도메인으로 이루어지는**비즈니스 로직의 관심사 분리를 위하여 서버 내에서 비동기 처리**를 하였습니다.
    * 트랜잭션을 고려하여 **이벤트 발행을 요청한 프로세스에서 정상적으로 커밋이 이루어진 후, 발생된 이벤트를 Listen**할 수 있게끔 구현하였습니다.
    * 이벤트의 타입이 확장될 수 있는 점을 염두하여 **어댑터 패턴**을 적용하였습니다.
* 문제 상황 및 해결
    * 클라이언트가 EventStream 객체를 통해 SSE의 메시지를 받게 되는데, 배포 환경에서 메시지를 뒤늦게 수신하는 문제가 있었습니다.
    * EC2의 스펙 문제를 의심하였으나, 네트워크 소스를 디버깅해본 결과, **EventStream을 통한 커넥션이 끊긴 후 모든 메시지가 수신되는 것을 확인**하였습니다.
    * 웹서버(Nginx)에서 SseEmitter 객체를 반환받는 엔드포인트에 **proxy-buffering 설정을 비활성화**하여 커넥션이 유지된 상황에서도 실시간 메시지 수신이 가능해졌습니다.
 

 
